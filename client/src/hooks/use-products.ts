import { useQuery, useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';
import { QUERY_KEYS } from '@/lib/constants';
import type { RecommendedProduct } from '@/components/products/ProductRecommendationCard';
import type { BundleSuggestion } from '@/components/products/BundleBuilder';

// ------ Types ------

export interface ProductTierInfo {
  id: string;
  slug: string;
  name: string;
  display_name: string;
  badge_color: string;
  badge_label: string;
  min_subscription_tier?: string;
}

export interface Product {
  id?: string;
  sku: string;
  name: string;
  category: string;
  subcategory: string | null;
  description: string;
  basePrice: number;
  suggestedRetail: number;
  imageUrl: string | null;
  ingredients: string | null;
  materials: string | null;
  certifications: string[];
  available: boolean;
  isTruvanutra?: boolean;
  commissionRate?: number;
  is_truvanutra?: boolean;
  // Snake-case aliases from API
  base_cost?: number;
  retail_price?: number;
  image_url?: string | null;
  sort_order?: number;
  // Tier & subscription gating
  tier: ProductTierInfo | null;
  accessible: boolean;
}

export interface ProductFilters {
  category?: string;
  tier?: string;
  search?: string;
  page?: number;
  limit?: number;
}

interface ProductsResponse {
  items: Product[];
  total: number;
  page?: number;
  limit?: number;
  categories: string[];
}

interface RecommendationResult {
  brandId: string;
  products: RecommendedProduct[];
  bundles: BundleSuggestion[];
  revenueProjection: {
    estimatedMonthlyRevenue: { low: number; mid: number; high: number };
    estimatedAnnualRevenue: { low: number; mid: number; high: number };
    conversionRate: number;
    avgOrderValue: number;
    methodology: string;
  } | null;
}

interface WizardStateResponse {
  brandId: string;
  name: string;
  status: string;
  wizardStep: string;
  wizardState: Record<string, unknown>;
  hasActiveSession: boolean;
  createdAt: string;
  updatedAt: string;
}

// ------ Hooks ------

/**
 * Fetch the product catalog with optional category filter.
 */
export function useProducts(category?: string) {
  return useQuery({
    queryKey: QUERY_KEYS.products(category),
    queryFn: () =>
      apiClient.get<ProductsResponse>('/api/v1/products', {
        params: category ? { category } : undefined,
      }),
  });
}

/**
 * Fetch the product catalog with rich filtering for the browse page.
 */
export function useBrowseProducts(filters: ProductFilters = {}) {
  const params: Record<string, string | number> = {};
  if (filters.category) params.category = filters.category;
  if (filters.tier) params.tier = filters.tier;
  if (filters.search) params.search = filters.search;
  if (filters.page) params.page = filters.page;
  if (filters.limit) params.limit = filters.limit;

  return useQuery({
    queryKey: QUERY_KEYS.browseProducts(filters as Record<string, unknown>),
    queryFn: () =>
      apiClient.get<ProductsResponse>('/api/v1/products', {
        params: Object.keys(params).length > 0 ? params : undefined,
      }),
    staleTime: 1000 * 60 * 5,
  });
}

/**
 * Fetch available product categories.
 */
export function useProductCategories() {
  return useQuery({
    queryKey: ['product-categories'],
    queryFn: () => apiClient.get<string[]>('/api/v1/products/categories'),
    staleTime: 1000 * 60 * 30, // 30 minutes -- categories rarely change
  });
}

/**
 * Fetch cached AI recommendations for a brand from wizard state.
 * Recommendations are stored under wizard_state['product-recommendations']
 * after being generated by POST /wizard/:brandId/recommend-products.
 */
export function useProductRecommendations(brandId: string | null) {
  return useQuery({
    queryKey: ['product-recommendations', brandId],
    queryFn: async () => {
      const state = await apiClient.get<WizardStateResponse>(
        `/api/v1/wizard/${brandId}/state`,
      );
      const recs = state?.wizardState?.['product-recommendations'] as
        | { products?: RecommendedProduct[]; bundles?: BundleSuggestion[]; revenueProjection?: RecommendationResult['revenueProjection'] }
        | undefined;
      if (!recs || !recs.products || recs.products.length === 0) return null;
      return {
        brandId: brandId!,
        products: recs.products,
        bundles: recs.bundles || [],
        revenueProjection: recs.revenueProjection || null,
      } as RecommendationResult;
    },
    enabled: !!brandId,
    staleTime: 1000 * 60 * 5, // 5 min cache
    retry: false, // Don't retry 404s
  });
}

/**
 * Generate AI product recommendations via Claude.
 * The server reads dossier/identity data from the brand's wizard_state,
 * so we only need to pass brandId. Optionally pass `regenerate: true`
 * to force regeneration or `preferences` for user hints.
 */
export function useGenerateRecommendations() {
  return useMutation({
    mutationFn: ({
      brandId,
      regenerate,
      preferences,
    }: {
      brandId: string;
      regenerate?: boolean;
      preferences?: Record<string, unknown>;
    }) =>
      apiClient.post<RecommendationResult>(
        `/api/v1/wizard/${brandId}/recommend-products`,
        { ...(regenerate && { regenerate }), ...(preferences && { preferences }) },
      ),
  });
}
